[
  {
    "objectID": "AS2.html",
    "href": "AS2.html",
    "title": "1. Basic Operations",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')\n%config inlineBackend.figure_format = 'retina'\n\n\n1\n\ndata = {\n    'Name': ['Virat', 'Dhoni', 'Rohit', 'Sachin', 'Gavaskar'],\n    'Math': [90, 80, 85, 70, 95],\n    'Science': [85, 88, 90, 75, 92],\n    'English': [78, 85, 82, 90, 88]\n}\ndf = pd.DataFrame(data)\ndf['tot'] = df['Math'] + df['Science'] + df['English']\ndf.head()\ndf.describe()\n\n\n  \n    \n\n\n\n\n\n\nMath\nScience\nEnglish\ntot\n\n\n\n\ncount\n5.000000\n5.000000\n5.000000\n5.000000\n\n\nmean\n84.000000\n86.000000\n84.600000\n254.600000\n\n\nstd\n9.617692\n6.670832\n4.774935\n14.240786\n\n\nmin\n70.000000\n75.000000\n78.000000\n235.000000\n\n\n25%\n80.000000\n85.000000\n82.000000\n253.000000\n\n\n50%\n85.000000\n88.000000\n85.000000\n253.000000\n\n\n75%\n90.000000\n90.000000\n88.000000\n257.000000\n\n\nmax\n95.000000\n92.000000\n90.000000\n275.000000\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\n\n2\n\n#remember to load the csv everytime we run this 1.2\nx = pd.read_csv('Book1.csv')\ndf = x.tail()\ndf\nprint(x.shape)\nprint(len(x.columns))\n\n(5, 4)\n4\n\n\n\n\n3\n\n#1.3\ndata = { 'Name': ['Virat', 'Dhoni', 'Rohit', 'Sachin', 'Gavaskar'],\n        'Employee ID': ['1', '2', '3', '4', '5'], 'Dept': ['AI', 'ML', 'AI', 'AI', 'ML'],\n         'Salary': [50000, 51000, 52000, 53000, 54000]\n         }\ndf = pd.DataFrame(data)\ndf.eval('bonus = Salary * 0.1', inplace = True)\ndf.eval('Salary = Salary * 1.2', inplace = True)\nprint(df)       #have printed both for comparision.\ndf.drop('Dept', axis = 1, inplace = True)\nprint(df)\n\n       Name Employee ID Dept  Salary   bonus\n0     Virat           1   AI   60000  5000.0\n1     Dhoni           2   ML   61200  5100.0\n2     Rohit           3   AI   62400  5200.0\n3    Sachin           4   AI   63600  5300.0\n4  Gavaskar           5   ML   64800  5400.0\n       Name Employee ID  Salary   bonus\n0     Virat           1   60000  5000.0\n1     Dhoni           2   61200  5100.0\n2     Rohit           3   62400  5200.0\n3    Sachin           4   63600  5300.0\n4  Gavaskar           5   64800  5400.0\n\n\n\n\n2. Indexing and Slicing\n\n\n1\n\n#2.1\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')\n%config inlineBackend.figure_format = 'retina'\ndata = {\n    'Employee': ['E1', 'E2', 'E3', 'E4', 'E5'],\n    'Department': ['HR', 'IT', 'Finance', 'IT', 'HR'],\n    'Salary': [50000, 60000, 55000, 58000, 52000],\n    'Performance_Rating': [8.2, 7.8, 8.5, 7.4, 8.0],\n    'Years_at_Company': [5, 3, 6, 2, 4]\n}\nres = pd.DataFrame(data)\nres2 = ((res['Department'] == 'HR') | (res['Department'] == 'IT')) & (res['Performance_Rating'] &gt;= 8) & ((res['Salary'] &lt; 55000) | (res['Years_at_Company'] &gt;= 4))\nres2\n\n\n\n\n\n\n\n\n0\n\n\n\n\n0\nTrue\n\n\n1\nFalse\n\n\n2\nFalse\n\n\n3\nFalse\n\n\n4\nTrue\n\n\n\n\ndtype: bool\n\n\n\n\n2\n\n#2.2\ndata = {\n    'Product': ['Laptop', 'Phone', 'Tablet', 'Monitor', 'Headphones'],\n    'Price': [800, 400, 300, 150, 50],\n    'Stock': [20, 35, 50, 10, 100],\n    'Rating': [4.5, 4.2, 3.8, 4.8, 4.0]\n}\nres = pd.DataFrame(data)\nres2 = res.iloc[-3:]\nres3 = res.iloc[-3:, 0:3]\nres3\n\n\n  \n    \n\n\n\n\n\n\nProduct\nPrice\nStock\n\n\n\n\n2\nTablet\n300\n50\n\n\n3\nMonitor\n150\n10\n\n\n4\nHeadphones\n50\n100\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n3\n\n#2.3\ndata = {\n    'Name': ['John', 'Sara', 'Tom', 'Alex', 'Julia'],\n    'Age': [29, 35, 40, 25, 31],\n    'Salary': [50000, 60000, 75000, 45000, 52000],\n    'Department': ['HR', 'Finance', 'IT', 'HR', 'IT']\n}\nres = pd.DataFrame(data)\nres2 = res.set_index('Name', inplace = False)\nres3 = res2.loc['Tom']\nprint(res3)\nres4 = res2.iloc[0:2, 1:3]\nprint(res4)\n\nAge              40\nSalary        75000\nDepartment       IT\nName: Tom, dtype: object\n      Salary Department\nName                   \nJohn   50000         HR\nSara   60000    Finance\n\n\n\n\n3. GroupBy and Aggregations\n\n\n1\n\n#3.1\ndata = pd.DataFrame({\n  \"StudentID\": [1, 2, 3, 2, 3, 1],\n  \"Subject\": [\"Math\", \"Science\", \"Math\",  \"Math\",\"Science\", \"Science\"],\n  \"Score\": [85, 90, 78, 88, 92, 95]\n})\nres = data.groupby('StudentID')['Score'].mean()\nres\n\n\n\n\n\n\n\n\nScore\n\n\nStudentID\n\n\n\n\n\n1\n90.0\n\n\n2\n89.0\n\n\n3\n85.0\n\n\n\n\ndtype: float64\n\n\n\n\n2\n\n#3.2\ndata = {\n    'Region' : ['1', '1', '2', '2', '3', '3', '4'],\n    'ID' : [11, 11, 13, 14, 14, 14, 15],\n    'Product' : ['toys', 'games', 'vessels', 'toys', 'Clothes', 'Clothes', 'Food'],\n    'Sales' : [100, 200, 150, 100, 400, 50, 1000]\n}\ndf = pd.DataFrame(data)\nres = df.groupby('Region')['Sales'].sum()\nprint(res)\nres2 = df.groupby('ID')['Sales'].mean()\nprint(res2)\n\nRegion\n1     300\n2     250\n3     450\n4    1000\nName: Sales, dtype: int64\nID\n11     150.000000\n13     150.000000\n14     183.333333\n15    1000.000000\nName: Sales, dtype: float64\n\n\n\n\n3\n\n#3.3\n#by both method df.eval and df column multiplication\ndf = pd.DataFrame({\n    'Category': ['Electronics', 'Electronics', 'Clothing', 'Clothing', 'Groceries', 'Groceries'],\n    'Order_ID': ['O1', 'O2', 'O3', 'O4', 'O5', 'O6'],\n    'Price': [1000, 500, 100, 200, 50, 60],\n    'Discount': [50, 25, 10, 20, 5, 6],\n    'Quantity': [1, 2, 3, 1, 4, 5]\n})\ndf.eval('tot_price = Price * Quantity', inplace=True)\nprint(df)\nres2 = df.groupby('Category')['tot_price'].sum()\nprint(res2)\ndf['disc'] = df['Discount'] * df['Quantity']\nres3 = df.groupby('Category')['disc'].sum()\nprint(res3)\nprint(df['disc'])\nres4 = df['disc'].mean()\nprint(res4)\n\n\n\n      Category Order_ID  Price  Discount  Quantity  tot_price\n0  Electronics       O1   1000        50         1       1000\n1  Electronics       O2    500        25         2       1000\n2     Clothing       O3    100        10         3        300\n3     Clothing       O4    200        20         1        200\n4    Groceries       O5     50         5         4        200\n5    Groceries       O6     60         6         5        300\nCategory\nClothing        500\nElectronics    2000\nGroceries       500\nName: tot_price, dtype: int64\nCategory\nClothing        50\nElectronics    100\nGroceries       50\nName: disc, dtype: int64\n0    50\n1    50\n2    30\n3    20\n4    20\n5    30\nName: disc, dtype: int64\n33.333333333333336\n\n\n\nres1 = df['tot_price']\ndf.iloc[res1.idxmax(), 1]\nres2 = df['Discount']\ndf.iloc[res2.idxmax(), 1]\n\n'O1'\n\n\n\n\n4. Handling Missing Data\n\n#4\n# Load the Titanic dataset\n\ndf = sns.load_dataset('titanic')\n\n# Select only numeric columns\nnumeric_df = df.select_dtypes(include=['float64', 'int64'])\n\n# Introducing missing values in the 'pclass' column\nnp.random.seed(42)\npclass_nan_indices = np.random.choice(numeric_df.index, size=int(0.05 * len(numeric_df)), replace=False)\nnumeric_df.loc[pclass_nan_indices, 'pclass'] = np.nan\n\n# Introducing missing values in the 'parch' column\nparch_nan_indices = np.random.choice(numeric_df.index, size=int(0.70 * len(numeric_df)), replace=False)\nnumeric_df.loc[parch_nan_indices, 'parch'] = np.nan\n\n\n#4.1\nnumeric_df_copy=numeric_df.copy()\nnumeric_df.head()\n\n\n  \n    \n\n\n\n\n\n\nsurvived\npclass\nage\nsibsp\nparch\nfare\n\n\n\n\n0\n0\n3.0\n22.0\n1\n0.0\n7.2500\n\n\n1\n1\n1.0\n38.0\n1\nNaN\n71.2833\n\n\n2\n1\n3.0\n26.0\n0\nNaN\n7.9250\n\n\n3\n1\n1.0\n35.0\n1\n0.0\n53.1000\n\n\n4\n0\n3.0\n35.0\n0\n0.0\n8.0500\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\nsns.heatmap(numeric_df)\n\n\n\n\n\n\n\n\n\nmissingvalues_count=numeric_df.isnull().sum()\nprint(missingvalues_count)\n\nsurvived      0\npclass       44\nage         177\nsibsp         0\nparch       623\nfare          0\ndtype: int64\n\n\n\nmiss_percent=numeric_df.isnull().mean()*100\ndf_dropped=numeric_df.loc[:,miss_percent&lt;=60]\n\ndisplay(df_dropped)\n\n\n  \n    \n\n\n\n\n\n\nsurvived\npclass\nage\nsibsp\nfare\n\n\n\n\n0\n0\n3.0\n22.0\n1\n7.2500\n\n\n1\n1\n1.0\n38.0\n1\n71.2833\n\n\n2\n1\n3.0\n26.0\n0\n7.9250\n\n\n3\n1\n1.0\n35.0\n1\n53.1000\n\n\n4\n0\n3.0\n35.0\n0\n8.0500\n\n\n...\n...\n...\n...\n...\n...\n\n\n886\n0\nNaN\n27.0\n0\n13.0000\n\n\n887\n1\n1.0\n19.0\n0\n30.0000\n\n\n888\n0\n3.0\nNaN\n1\n23.4500\n\n\n889\n1\n1.0\n26.0\n0\n30.0000\n\n\n890\n0\n3.0\n32.0\n0\n7.7500\n\n\n\n\n891 rows × 5 columns\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n#4.2\nmode=numeric_df['pclass'].mode()\nnumeric_df['pclass'].fillna(mode, inplace=True)\n\ndisplay(numeric_df)\n\n#mode imputation was appropriate for his column because it will capture the most common category. We can't use mean imputation because we need answer out of 1,2,3\n#I would use mean imputation for age because we want average age of all the passengers for filling NA values.\n\nmean=numeric_df['age'].mean()\nnumeric_df['age'].fillna(mean, inplace=True)\n\n\ndisplay(numeric_df)\nsns.heatmap(numeric_df) #to check if NA values have vanished\n\n\n  \n    \n\n\n\n\n\n\nsurvived\npclass\nage\nsibsp\nparch\nfare\n\n\n\n\n0\n0\n3.0\n22.0\n1\n0.0\n7.2500\n\n\n1\n1\n1.0\n38.0\n1\nNaN\n71.2833\n\n\n2\n1\n3.0\n26.0\n0\nNaN\n7.9250\n\n\n3\n1\n1.0\n35.0\n1\n0.0\n53.1000\n\n\n4\n0\n3.0\n35.0\n0\n0.0\n8.0500\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n886\n0\nNaN\n27.0\n0\n0.0\n13.0000\n\n\n887\n1\n1.0\n19.0\n0\nNaN\n30.0000\n\n\n888\n0\n3.0\nNaN\n1\nNaN\n23.4500\n\n\n889\n1\n1.0\n26.0\n0\nNaN\n30.0000\n\n\n890\n0\n3.0\n32.0\n0\n0.0\n7.7500\n\n\n\n\n891 rows × 6 columns\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n  \n    \n\n\n\n\n\n\nsurvived\npclass\nage\nsibsp\nparch\nfare\n\n\n\n\n0\n0\n3.0\n22.000000\n1\n0.0\n7.2500\n\n\n1\n1\n1.0\n38.000000\n1\nNaN\n71.2833\n\n\n2\n1\n3.0\n26.000000\n0\nNaN\n7.9250\n\n\n3\n1\n1.0\n35.000000\n1\n0.0\n53.1000\n\n\n4\n0\n3.0\n35.000000\n0\n0.0\n8.0500\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n886\n0\nNaN\n27.000000\n0\n0.0\n13.0000\n\n\n887\n1\n1.0\n19.000000\n0\nNaN\n30.0000\n\n\n888\n0\n3.0\n29.699118\n1\nNaN\n23.4500\n\n\n889\n1\n1.0\n26.000000\n0\nNaN\n30.0000\n\n\n890\n0\n3.0\n32.000000\n0\n0.0\n7.7500\n\n\n\n\n891 rows × 6 columns\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n\n\n\n\n\n\n#4.3\nprint(numeric_df_copy)\nprint(numeric_df)\nprint(numeric_df_copy.isnull().sum())\nprint('\\n')\nprint(numeric_df.isnull().mean())\n\n     survived  pclass   age  sibsp  parch     fare\n0           0     3.0  22.0      1    0.0   7.2500\n1           1     1.0  38.0      1    NaN  71.2833\n2           1     3.0  26.0      0    NaN   7.9250\n3           1     1.0  35.0      1    0.0  53.1000\n4           0     3.0  35.0      0    0.0   8.0500\n..        ...     ...   ...    ...    ...      ...\n886         0     NaN  27.0      0    0.0  13.0000\n887         1     1.0  19.0      0    NaN  30.0000\n888         0     3.0   NaN      1    NaN  23.4500\n889         1     1.0  26.0      0    NaN  30.0000\n890         0     3.0  32.0      0    0.0   7.7500\n\n[891 rows x 6 columns]\n     survived  pclass        age  sibsp  parch     fare\n0           0     3.0  22.000000      1    0.0   7.2500\n1           1     1.0  38.000000      1    NaN  71.2833\n2           1     3.0  26.000000      0    NaN   7.9250\n3           1     1.0  35.000000      1    0.0  53.1000\n4           0     3.0  35.000000      0    0.0   8.0500\n..        ...     ...        ...    ...    ...      ...\n886         0     NaN  27.000000      0    0.0  13.0000\n887         1     1.0  19.000000      0    NaN  30.0000\n888         0     3.0  29.699118      1    NaN  23.4500\n889         1     1.0  26.000000      0    NaN  30.0000\n890         0     3.0  32.000000      0    0.0   7.7500\n\n[891 rows x 6 columns]\nsurvived      0\npclass       44\nage         177\nsibsp         0\nparch       623\nfare          0\ndtype: int64\n\n\nsurvived    0.000000\npclass      0.049383\nage         0.000000\nsibsp       0.000000\nparch       0.699214\nfare        0.000000\ndtype: float64\n\n\n\n\n5. Pandas: Merging Joining and Concatenation\n\n\n1\n\n#5.1\ndata1 = {\n    'student_id': [1, 2, 3, 4],\n    'name': ['Alice', 'Bob', 'Charlie', 'David']\n}\ndata2 = {\n    'student_id': [2, 3, 4, 5],\n    'grade': ['A', 'B', 'C', 'D']\n}\n\ndf1 = pd.DataFrame(data1)\ndf2 = pd.DataFrame(data2)\nres = pd.merge(df1, df2, on='student_id', how='inner')\nres\n\n\n  \n    \n\n\n\n\n\n\nstudent_id\nname\ngrade\n\n\n\n\n0\n2\nBob\nA\n\n\n1\n3\nCharlie\nB\n\n\n2\n4\nDavid\nC\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n2\n\n#5.2\nemployees_data = {\n    'employee_id': [1, 2, 3, 4],\n    'employee_name': ['Alice', 'Bob', 'Charlie', 'David']\n}\ndepartments_data = {\n    'employee_id': [2, 3, 4, 1],\n    'department_name': ['A', 'B', 'C', 'D']\n}\n\nemployees = pd.DataFrame(employees_data)\ndepartments = pd.DataFrame(departments_data)\n\nres = pd.merge(employees, departments, how='outer')\nres\n\n\n  \n    \n\n\n\n\n\n\nemployee_id\nemployee_name\ndepartment_name\n\n\n\n\n0\n1\nAlice\nD\n\n\n1\n2\nBob\nA\n\n\n2\n3\nCharlie\nB\n\n\n3\n4\nDavid\nC\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n3\n\n#5.3\ndf1 = {\n    'student_id': [1, 2, 3, 4],\n    'name': ['Alice', 'Bob', 'Charlie', 'David']\n}\ndf2 = {\n    'student_id': [5, 6, 7, 8],\n    'name': ['Anish', 'Divakar', 'Vaibhav', 'Tanvi']\n}\n\ndf_a = pd.DataFrame(df1)\ndf_b = pd.DataFrame(df2)\nres = pd.concat([df_a, df_b], ignore_index=True)\nres\n\n\n  \n    \n\n\n\n\n\n\nstudent_id\nname\n\n\n\n\n0\n1\nAlice\n\n\n1\n2\nBob\n\n\n2\n3\nCharlie\n\n\n3\n4\nDavid\n\n\n0\n5\nAnish\n\n\n1\n6\nDivakar\n\n\n2\n7\nVaibhav\n\n\n3\n8\nTanvi\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n\n6. Pandas: Advanced Operations (Evaluation and Query)\n\n\n1 and 2\n\n#6.1 AND 6.2\nfrom sklearn.datasets import load_iris\n\n\niris = load_iris()\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)\nprint(df.head())\ndf.describe()\n\n   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)\n0                5.1               3.5                1.4               0.2\n1                4.9               3.0                1.4               0.2\n2                4.7               3.2                1.3               0.2\n3                4.6               3.1                1.5               0.2\n4                5.0               3.6                1.4               0.2\n\n\n\n  \n    \n\n\n\n\n\n\nsepal length (cm)\nsepal width (cm)\npetal length (cm)\npetal width (cm)\n\n\n\n\ncount\n150.000000\n150.000000\n150.000000\n150.000000\n\n\nmean\n5.843333\n3.057333\n3.758000\n1.199333\n\n\nstd\n0.828066\n0.435866\n1.765298\n0.762238\n\n\nmin\n4.300000\n2.000000\n1.000000\n0.100000\n\n\n25%\n5.100000\n2.800000\n1.600000\n0.300000\n\n\n50%\n5.800000\n3.000000\n4.350000\n1.300000\n\n\n75%\n6.400000\n3.300000\n5.100000\n1.800000\n\n\nmax\n7.900000\n4.400000\n6.900000\n2.500000\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n    \n  \n\n\n\n\n3\n\n#6.3\nfrom sklearn.datasets import load_iris\niris = load_iris()\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)\ndf['species'] = iris.target\nres = df.query('`sepal length (cm)` &gt; 6.5 and `petal length (cm)` &gt; 5')\nres2 = df.query('species == 2 and `petal width (cm)` &lt; 2')\nprint(res)\nprint(res2)\n\n     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)  \\\n102                7.1               3.0                5.9               2.1   \n105                7.6               3.0                6.6               2.1   \n107                7.3               2.9                6.3               1.8   \n108                6.7               2.5                5.8               1.8   \n109                7.2               3.6                6.1               2.5   \n112                6.8               3.0                5.5               2.1   \n117                7.7               3.8                6.7               2.2   \n118                7.7               2.6                6.9               2.3   \n120                6.9               3.2                5.7               2.3   \n122                7.7               2.8                6.7               2.0   \n124                6.7               3.3                5.7               2.1   \n125                7.2               3.2                6.0               1.8   \n129                7.2               3.0                5.8               1.6   \n130                7.4               2.8                6.1               1.9   \n131                7.9               3.8                6.4               2.0   \n135                7.7               3.0                6.1               2.3   \n139                6.9               3.1                5.4               2.1   \n140                6.7               3.1                5.6               2.4   \n141                6.9               3.1                5.1               2.3   \n143                6.8               3.2                5.9               2.3   \n144                6.7               3.3                5.7               2.5   \n145                6.7               3.0                5.2               2.3   \n\n     species  \n102        2  \n105        2  \n107        2  \n108        2  \n109        2  \n112        2  \n117        2  \n118        2  \n120        2  \n122        2  \n124        2  \n125        2  \n129        2  \n130        2  \n131        2  \n135        2  \n139        2  \n140        2  \n141        2  \n143        2  \n144        2  \n145        2  \n     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)  \\\n101                5.8               2.7                5.1               1.9   \n103                6.3               2.9                5.6               1.8   \n106                4.9               2.5                4.5               1.7   \n107                7.3               2.9                6.3               1.8   \n108                6.7               2.5                5.8               1.8   \n111                6.4               2.7                5.3               1.9   \n116                6.5               3.0                5.5               1.8   \n119                6.0               2.2                5.0               1.5   \n123                6.3               2.7                4.9               1.8   \n125                7.2               3.2                6.0               1.8   \n126                6.2               2.8                4.8               1.8   \n127                6.1               3.0                4.9               1.8   \n129                7.2               3.0                5.8               1.6   \n130                7.4               2.8                6.1               1.9   \n133                6.3               2.8                5.1               1.5   \n134                6.1               2.6                5.6               1.4   \n137                6.4               3.1                5.5               1.8   \n138                6.0               3.0                4.8               1.8   \n142                5.8               2.7                5.1               1.9   \n146                6.3               2.5                5.0               1.9   \n149                5.9               3.0                5.1               1.8   \n\n     species  \n101        2  \n103        2  \n106        2  \n107        2  \n108        2  \n111        2  \n116        2  \n119        2  \n123        2  \n125        2  \n126        2  \n127        2  \n129        2  \n130        2  \n133        2  \n134        2  \n137        2  \n138        2  \n142        2  \n146        2  \n149        2  \n\n\n\n\n4\n\n#6.4\ndf.eval('area = petal_length_cm * petal_width_cm', inplace=True)\ndf['area'].sort_values()\ndf['area'].head()\nres = df.query('area &gt; 10 and sepal_length_cm &gt; 5 and sepal_length_cm &lt; 7')\nres\n\n\n\n\n\n\n\n\narea\n\n\n\n\n0\n0.28\n\n\n1\n0.28\n\n\n2\n0.26\n\n\n3\n0.30\n\n\n4\n0.28\n\n\n...\n...\n\n\n145\n11.96\n\n\n146\n9.50\n\n\n147\n10.40\n\n\n148\n12.42\n\n\n149\n9.18\n\n\n\n\n150 rows × 1 columns\ndtype: float64\n\n\n\n\n5\n\n#6.5\nimport matplotlib.pyplot as plt\n\navg = df['petal width (cm)'].mean()\nprint(avg)\ncnt = df['species'].count()\nprint(cnt)\nplt.scatter(df['sepal length (cm)'], df['petal length (cm)'])\nplt.xlabel('sepal length (cm)', color='red')\nplt.ylabel('petal length (cm)',color='blue')\nplt.show()\n\n1.1993333333333336\n150\n\n\n\n\n\n\n\n\n\n\n\n7. Matplotlib: Basic Plotting Questions\n\n\n1\n\n#7.1\nx = np.linspace(0, 2 * np.pi, 100)\ny = np.sin(x)\nplt.plot(x, y)\nplt.xlabel('x')\nplt.ylabel('sin(x)')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2\n\n#7.2\nx = np.linspace(0, 2 * np.pi, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\nplt.plot(x, y1, label='sin(x)', color='crimson')\nplt.plot(x, y2, label='cos(x)', color='blue')\nplt.xlabel('x')\nplt.ylabel('sin(x), cos(x)')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3\n\n#7.3\nx = np.linspace(-10, 10, 100)\ny = x * x\nplt.plot(x, y, color='crimson', linewidth=6)\nplt.xlabel('x')\nplt.ylabel('x^2', color='crimson')\nplt.title('quadrature')\n\nplt.grid()\n\n\n\n\n\n\n\n\n\n\n8a. Bar Plot\n\n\n1\n\n#8.1\ntips = sns.load_dataset('tips')\nres = tips.groupby('day')['tip'].mean()\nres.plot(kind = 'bar', x = 'day', y ='tip')\n\n\n\n\n\n\n\n\n\n\n\n8b. Scatter Plot\n\n\n1\n\n#8.2\ntips = sns.load_dataset('tips')\nx = tips['total_bill']\ny = tips['tip']\nplt.scatter(x, y, color='crimson')\nplt.xlabel('total_bill')\nplt.ylabel('tip')\nplt.title('Total Bill v/s Tips', color='blue')\nplt.show()\n#the relationship suggests that the amount of tip is proportional to the total_bill suggesting that customers who dine more have more tendency to give tips.\n\n\n\n\n\n\n\n\n\n\n9. Matplotlib: Subplots and Layouts\n\n\n1\n\n#9.1\nx = np.linspace(0.1, 2 * np.pi ,100)\nres1 = np.sin(x)\nres2 = np.cos(x)\nres3 = np.exp(x)\nres4 = np.log(x);\nfig, ax = plt.subplots(2, 2)\nax[0, 0].plot(x, res1)\nax[0, 0].set_xlabel(\"x\")\nax[0, 0].set_ylabel(\"sinx\")\n\nax[0, 1].plot(x, res2)\n\nax[1, 0].plot(x, res3)\nax[1, 1].plot(x, res4)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2\n\narr = np.random.rand(100)\nfig,axes = plt.subplots(2,1,sharex=True)\naxes[0].scatter(np.linspace(0.0,1.0,100),arr)\naxes[1].hist(arr)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n10. Matplotlib: Advanced Customization\n\n\n1\n\n#10.1\nx = np.linspace(-10, 10, 100)\ny = x * x\nplt.plot(x, y)\nplt.xticks(np.arange(-10, 11, 2), rotation = 45)\nplt.yticks(np.arange(0, 101, 5))\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2\n\n#10.2\ndata = np.linspace(0,2*np.pi,num=100)\ndata_tan = np.linspace(-np.pi/2.1,np.pi/2.1,num=100)\nfig,axes = plt.subplots(2,2)\nplt.figure(figsize=(20,20))\nl1=axes[0,0].plot(data,np.sin(data),color='orange',label='Sin(x)')\nl2=axes[0,1].plot(data,np.cos(data),color='r',label='Cos(x)')\nl3=axes[1,1].plot(data,np.tan(data_tan),color='k',label='Tan(x)')\nl4=axes[1,0].plot(data,(np.sin(data)**2+np.cos(data)**2),color='b',label='Sin^2(x)+Cos^2(x)')\nfig.legend(loc='upper left')\nfor i in range(2):\n    for j in range(2):\n            axes[i,j].grid(alpha=0.7)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n&lt;Figure size 2000x2000 with 0 Axes&gt;\n\n\n\n\n3.\n\n\n\n\n\n\n\n\n\n\n\n\n4.\n\nx = np.arange(1,11)\ny = np.random.randint(0,10,10)\nx_pos,y_pos = np.argmax(y),np.max(y)\nplt.scatter(x,y,80,marker='*',color='r')\nplt.annotate(f\"({x_pos+1},{y_pos})\",xy=(x_pos+1,y_pos),horizontalalignment='center',verticalalignment='bottom')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n5.\n\nmatrix = pd.DataFrame(np.round(np.random.random((5,5)),2))\nsns.heatmap(matrix,cmap='coolwarm',vmin=0,vmax=1,annot=True)\n\n\n\n\n\n\n\n\n\n\n6.\n\nx = np.linspace(-10, 10, 100)\ny = np.linspace(-10, 10, 100)\nX, Y = np.meshgrid(x,y)\npd.DataFrame(X)\nZ = np.sin(np.sqrt(X**2 + Y**2))\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\nsurface = ax.plot_surface(X, Y, Z, cmap='coolwarm')\nax.set_title('3D Plot of sin(sqrt(x^2+y^2))', fontsize=15)\nax.set_xlabel('X-axis', fontsize=10)\nax.set_ylabel('Y-axis', fontsize=10)\nax.set_zlabel('Z-axis', fontsize=10)\n\nfig.colorbar(surface,pad=0.1)\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Expostion_Assignment",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "The Authors:\nAawish K Sudhish (24110003)\nBhaumik S Malaviya (24110069)\nParam Tanna (24110236)\nWe had a good amount of fun in learning and making this project!"
  },
  {
    "objectID": "PSDV.html",
    "href": "PSDV.html",
    "title": "1. Title",
    "section": "",
    "text": "Faceting: Visualizing data with multi-axis subplots\n\n\nBuilding structured multi-plot grids using FacetGrrid\n\n\n2. Introduction\nWhen analysing large datasets with multiple data variables, an efficient method is to create multiple subplots using different subsets of your data. FacetGrid allows for the easy implementation of structured multi-plot grids using the seaborn library, which is built on top of matplotlib.\n\n\nInstallation and setup\nFacetGrid is part of the seaborn library of python and only needs seaborn library to be installed along with python 3.8 or higher. The steps for the installation is:\nWindows users: 1. Open your cmd or powershell(assuming you have installed pip and added it to the environmental variables). 2. Type pip install seaborn. 3. The library should be installed and now can be used\n(errors can occur if python is not installed properly or pip is not recognized)\nfixes: using the terminal inside vs adding pip reinstalling python\nMac users: 1. check if python is installed creating virtual environment 2.\nLinux users: 1.\nsetup:\nimport the seaborn library by typing import seaborn as sns\n\n\nKey Features and explanation\n.1 Conditional multiplots\nFacetGrid allows you to represent data among subsets of your dataset for efficient analysis. This also helps with visualising the data and drawing new insights for data. FacetGrid allows comparison along the three dimensions of row, column and hue.\nThis is done by first creating a FacetGrid object using a DataFrame with the arguments of ‘col’ and ‘row’ and ‘hue’, which will form the grid’s row, column and hue. map_dataframe or map is used to plot graphs onto the grid with individual subsets of the main dataframe, which is sorted by the rows and columns of the FacetGrid object.\nEX\n.2 Using Custom functions\nFacetGrid also allows you to use custom functions which are not limited to the main matplotlib or seaborn function. Facetgrid requires the custom function to follow some rules mentioned by the official documentation of Facetgrid:\n*It must plot onto the “currently active” matplotlib Axes. This will be true of functions in the matplotlib.pyplot namespace, and you can call matplotlib.pyplot.gca() to get a reference to the current Axes if you want to work directly with its methods.\n*It must accept the data that it plots in positional arguments. Internally, FacetGrid will pass a Series of data for each of the named positional arguments passed to FacetGrid.map().\n*It must be able to accept color and label keyword arguments, and, ideally, it will do something useful with them. In most cases, it’s easiest to catch a generic dictionary of **kwargs and pass it along to the underlying plotting function.\n.3 Plotting pair wise data relationships using PairGrid\n*Unlike Facetgrid, where each plot shows the same relationship along different levels of variable in rows and columns in the same plot type. PairGrid allows you to see plot with different relationships, like in a matrix where the relationship is decided by the given row and column. The allows you to get a quick summary of the relationship between two variables in a scattered way.\n\n\nCode Example\n\nimport seaborn as sns\npenguins_df = sns.load_dataset(\"penguins\")\npenguins_df.head()\np = sns.FacetGrid(penguins_df,col='island',row='species',hue='sex',sharey=False,sharex=False,palette='magma')\np.map_dataframe(sns.scatterplot,x='body_mass_g',y='bill_length_mm')\np.set_axis_labels(x_var='Body mass(g)',y_var='Bill length(mm)')\np.set_titles(col_template='{col_name} Island',row_template='{row_name} Penguin')\np.add_legend()\n\n\n\n\n\n\n\n\n\nimport seaborn as sns\ndiamonds = sns.load_dataset(\"diamonds\")\nd = sns.FacetGrid(diamonds,col='cut',hue='color',palette='prism',sharey=False)\nd.map_dataframe(sns.barplot,x='clarity',y='carat')\nd.set_axis_labels(x_var='Clarity',y_var='Carat')\nd.set_titles(col_template='{col_name} Cut')\nd.add_legend()\nprint(diamonds.head())\n\n   carat      cut color clarity  depth  table  price     x     y     z\n0   0.23    Ideal     E     SI2   61.5   55.0    326  3.95  3.98  2.43\n1   0.21  Premium     E     SI1   59.8   61.0    326  3.89  3.84  2.31\n2   0.23     Good     E     VS1   56.9   65.0    327  4.05  4.07  2.31\n3   0.29  Premium     I     VS2   62.4   58.0    334  4.20  4.23  2.63\n4   0.31     Good     J     SI2   63.3   58.0    335  4.34  4.35  2.75\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\ndef add_mean_line(data, var=None, **kws):\n    \n    # If no variable provided skip adding mean line\n    if not var: return\n    \n    #Calculate mean for each group\n    m = np.mean(data[var])\n    \n    #Get current axis\n    ax = plt.gca()\n    \n    #add line at group mean\n    ax.axvline(m, color='maroon', lw=3, ls='--')\n    \n    #annotate group mean\n    x_pos=0.65\n    if m &gt; 5000: x_pos=0.2\n    ax.text(x_pos, 0.7, f'mean={m:.0f}', \n            transform=ax.transAxes,   #transforms positions to range from (0,0) to (1,1)\n            color='maroon', fontweight='bold', fontsize=12)\n    \ndiamonds = sns.load_dataset(\"diamonds\")\nd = sns.FacetGrid(diamonds,col='cut')\nd.map_dataframe(sns.kdeplot,x='carat',fill=True,linewidth=2)\nd.map_dataframe(add_mean_line,var='carat')\nd.set_titles(col_template='{col_name} Cut')\nd.add_legend()"
  },
  {
    "objectID": "PSDV (1).html",
    "href": "PSDV (1).html",
    "title": "Faceting using FacetGrid",
    "section": "",
    "text": "1. Introduction\nIn this project, we are going to be visualizing data with multi - axis subplots and building structured multi-plot grids using FacetGrid. So, basically, when analysing large datasets with multiple data variables, an efficient method is to create multiple subplots using different subsets of your data. FacetGrid allows for the easy implementation of structured multi-plot grids using the seaborn library, which is built on top of matplotlib.\n\n\n2. Installation and setup\nFacetGrid is part of the seaborn library of python and only needs seaborn library to be installed along with python 3.8 or higher. The steps for the installation is:\n\\(Windows\\) \\(users\\):\n\nOpen your cmd or powershell(assuming you have installed pip and added it to the environmental variables).\nType pip install seaborn.\nThe library should be installed and now can be used\n\n(errors can occur if python is not installed properly or pip is not recognized)\nfixes: using the terminal inside vs adding pip reinstalling python\n\\(Mac\\) \\(users\\): We will install the program using HomeBrew. If you don’t have HomeBrew, then:\n\nOpen terminal\nType: /bin/bash -c “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)”\nConfirm : brew –version\n\nNow, that we have installed homebrew using the terminal, follow the procedure below to install FacetGrid. The commands are given to the right of the colon (:) and their functionalities on the left.\n\nCheck if Python is installed: python3 –version Expected output: Version. Else : brew install python\nCheck if pip is installed: pip3 –version Expected output: Version. Else : python3 -m ensurepip –default-pip\nCreate a virual environment to keep dependencies organised : python3 -m venv venv source venv/bin/activate\nNow, install Seaborn using pip : pip install seaborn Expected output: Installation. Else: pip install numpy pandas matplotlib\nYou are all set to use your brand new FacetGrid and build stuff! Check if its installed correctly by running : python3 -c “import seaborn as sns; print(sns.__version__)” Expected output : Version.\n\n\n\n3. Key Features, Explanations and Code\n\n\\(Conditional\\) \\(multiplots\\)\n\nFacetGrid allows you to represent data among subsets of your dataset for efficient analysis. This also helps with visualising the data and drawing new insights for data. FacetGrid allows comparison along the three dimensions of row, column and hue.\nThis is done by first creating a FacetGrid object using a DataFrame with the arguments of ‘col’ and ‘row’ and ‘hue’, which will form the grid’s row, column and hue. map_dataframe or map is used to plot graphs onto the grid with individual subsets of the main dataframe, which is sorted by the rows and columns of the FacetGrid object.\nBelow is the working code for the above theory.\n\nimport seaborn as sns\npenguins_df = sns.load_dataset(\"penguins\")\npenguins_df.head()\np = sns.FacetGrid(penguins_df,col='island',row='species',hue='sex',sharey=False,sharex=False,palette='magma')\np.map_dataframe(sns.scatterplot,x='body_mass_g',y='bill_length_mm')\np.set_axis_labels(x_var='Body mass(g)',y_var='Bill length(mm)')\np.set_titles(col_template='{col_name} Island',row_template='{row_name} Penguin')\np.add_legend()\n\n\n\n\n\n\n\n\n\n\\(Using\\) \\(Custom\\) \\(functions\\)\n\nFacetGrid also allows you to use custom functions which are not limited to the main matplotlib or seaborn function. Facetgrid requires the custom function to follow some rules mentioned by the official documentation of Facetgrid:\n\nIt must plot onto the “currently active” matplotlib Axes. This will be true of functions in the matplotlib.pyplot namespace, and you can call matplotlib.pyplot.gca() to get a reference to the current Axes if you want to work directly with its methods.\nIt must accept the data that it plots in positional arguments. Internally, FacetGrid will pass a Series of data for each of the named positional arguments passed to FacetGrid.map().\nIt must be able to accept color and label keyword arguments, and, ideally, it will do something useful with them. In most cases, it’s easiest to catch a generic dictionary of **kwargs and pass it along to the underlying plotting function.\n\nBelow is the working code for the above theory.\n\nimport seaborn as sns\ndiamonds = sns.load_dataset(\"diamonds\")\nd = sns.FacetGrid(diamonds,col='cut',hue='color',palette='prism',sharey=False)\nd.map_dataframe(sns.barplot,x='clarity',y='carat')\nd.set_axis_labels(x_var='Clarity',y_var='Carat')\nd.set_titles(col_template='{col_name} Cut')\nd.add_legend()\nprint(diamonds.head())\n\n   carat      cut color clarity  depth  table  price     x     y     z\n0   0.23    Ideal     E     SI2   61.5   55.0    326  3.95  3.98  2.43\n1   0.21  Premium     E     SI1   59.8   61.0    326  3.89  3.84  2.31\n2   0.23     Good     E     VS1   56.9   65.0    327  4.05  4.07  2.31\n3   0.29  Premium     I     VS2   62.4   58.0    334  4.20  4.23  2.63\n4   0.31     Good     J     SI2   63.3   58.0    335  4.34  4.35  2.75\n\n\n\n\n\n\n\n\n\n\n\\(Plotting\\) \\(pair\\) \\(wise\\) \\(data\\) \\(relationships\\) \\(using\\) \\(PairGrid\\)\n\n*Unlike Facetgrid, where each plot shows the same relationship along different levels of variable in rows and columns in the same plot type. PairGrid allows you to see plot with different relationships, like in a matrix where the relationship is decided by the given row and column. The allows you to get a quick summary of the relationship between two variables in a scattered way.\nBelow is the working code for the above theory.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\ndef add_mean_line(data, var=None, **kws):\n    \n    # If no variable provided skip adding mean line\n    if not var: return\n    \n    #Calculate mean for each group\n    m = np.mean(data[var])\n    \n    #Get current axis\n    ax = plt.gca()\n    \n    #add line at group mean\n    ax.axvline(m, color='maroon', lw=3, ls='--')\n    \n    #annotate group mean\n    x_pos=0.65\n    if m &gt; 5000: x_pos=0.2\n    ax.text(x_pos, 0.7, f'mean={m:.0f}', \n            transform=ax.transAxes,   #transforms positions to range from (0,0) to (1,1)\n            color='maroon', fontweight='bold', fontsize=12)\n    \ndiamonds = sns.load_dataset(\"diamonds\")\nd = sns.FacetGrid(diamonds,col='cut')\nd.map_dataframe(sns.kdeplot,x='carat',fill=True,linewidth=2)\nd.map_dataframe(add_mean_line,var='carat')\nd.set_titles(col_template='{col_name} Cut')\nd.add_legend()\n\n\n\n\n\n\n\n\nPairgrid allows us to have different plots at different locations in our grid. PairGrid also result in the diagonal elements of the grid having the same variables on the x ans y axis. Seaborn can interpret this as a univariant data and allow us to plot univariant plots like histplot, KDE plots, etc. Another consequence of this is that there are mirrored elements in the upper and lower part of the diagonal of the grid.\n\n\n4. Use Cases\nFacetgrid is mainly used in those cases where comparative visualizations are required and the data is divided into different categories. Its main purpose is to simplify multi - category analysis. Some of the fields in which the use of FacetGrid may arise are:\n\nMedical & Healthcare Data Analysis\nFinancial Data and Analysis of Stocks\nData analytics which will be used for marketing\nScientific Research and Experimental Data\nSports analytics (See the movie: Moneyball)\nEnvironmental and Climate Analytics\n\nWhich are all data - intensive fields where a lot of data is to be processed, and simple observations and correlations may make a world of difference in any kind of variable. This is why FacetGrid is very powerful in analytics. It’s free visualization!\n\n\n5. Concluding Remarks\nSo, as the sun sets on this introduction, we have learnt about the installation of FacetGrid on various platforms, key features and their explanations with working code which included Conditional Multiplots, Custom Functions, and PairGrid for Pairwise Relationships. We also saw how FacetGrid is used in areas which are data - rich like stocks, sports and market analytics to visualize and make correlations. To sign off, it simplifies multi - category analysis which make datasets more interpretable and insightful.\n\n\n\n\n\n6. References and Further Reading\n\nhttps://seaborn.pydata.org/generated/seaborn.FacetGrid.html\nhttp://youtube.com/watch?v=V_a0-1lU4AU\nhttps://www.youtube.com/watch?v=D4qN59vnSx0\nhttps://www.youtube.com/watch?v=vMNNOwriAbQ"
  }
]